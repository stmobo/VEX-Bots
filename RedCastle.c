#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, in2,    autoSelector,   sensorPotentiometer)
#pragma config(Sensor, in3,    posSelector,    sensorPotentiometer)
#pragma config(Sensor, dgtl1,  catapultLim,    sensorTouch)
#pragma config(Sensor, I2C_1,  catapultEnc,    sensorNone)
#pragma config(Sensor, I2C_2,  hangEnc,        sensorNone)
#pragma config(Sensor, I2C_3,  rightEnc,       sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  leftEnc,        sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           RBack,         tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           RFront,        tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port3,           rightLowerIntake, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rightUpperIntake, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           hangMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           leftUpperIntake, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           leftLowerIntake, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           LFront,        tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port10,          LBack,         tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#include "./CrossingWaves.c"

/* Loop parameters */
float leftP = 3.0;
float rightP = 3.0;
float turnP = 2;
int maxMotorOut = 63;

float turnErrThreshold = 1.0;
int driveErrThreshold = 5;

int interruptableTurnTimeout = 2000;

bool limSwitchEnabled = false;

int dividePotentiometer(int sensorIn, int nSelects) {
	int thresholds = 1024 / nSelects;
	int n = sensorIn / thresholds;
	return n;
}

tbhData turnControl;
tbhData leftControl;
tbhData rightControl;

bool autoMode = false;

void resetGyro() {
	sensorValue[gyro] = 0;
}

void resetEncoders() {
	resetMotorEncoder(LFront);
	resetMotorEncoder(RFront);
}

/* Gyro positive = ccw, gyro negative = cw */
float readGyro() {
	float v = (float)SensorValue[gyro];
	v /= 10;
	return v;
}
/*
task LCDUpdate() {
	while(true) {
		float curAngle = readGyro();

		clearLCDLine(0);
		clearLCDLine(1);

		if(turnControl.active) {
			displayLCDString(0, 0, "Turn Active: ");
			displayLCDNumber(0, 13, (int)turnControl.setpoint);


			displayLCDString(1, 0, "Err: ");
			displayLCDNumber(1, 5, (int)turnControl.err);


			displayLCDString(1, 10, "Out: ");
			displayLCDNumber(1, 15, (int)turnControl.output);
		} else if(autoMode) {
			displayLCDString(0, 0, "Autonomous Active");
		} else {
			displayLCDString(0, 0, "Driver Controlled");
		}

		sleep(5);
	}
}
*/
void stopMotors() {
	motor[LBack] = motor[LFront] = motor[RBack] = motor[RFront] = 0;
}

float wheelCircumference = 2 * PI * 2; // 4in wheel diameter = 2in radius.
float ticksPerRevolution = 392;

int inToEncoderTicks(float inches) {
	float t = inches * (ticksPerRevolution / wheelCircumference);
	return t;
};

// debugger state:
int lastEncoderDelta = 0;
task autoDriveDebug() {
	int state = 0;
	clearDebugStream();
	//stopTask(LCDUpdate); // prevent conflicts
	while(true) {
		clearLCDLine(0);
		clearLCDLine(1);
		if(state == 0) {
			// Display Left-Side data:
			displayLCDString(0, 0, "Val:");
			displayLCDString(1, 0, "Err:");
			
			datalogDataGroupStart();
			dataLogAddValue(0, getMotorEncoder(LFront));
			dataLogAddValue(1, getMotorEncoder(RFront));
			dataLogAddValue(2, leftControl.err);
			dataLogAddValue(3, rightControl.err);
			dataLogAddValue(4, leftControl.output);
			dataLogAddValue(5, rightControl.output);
			dataLogAddValue(6, lastEncoderDelta);
			datalogDataGroupEnd();

			
			
			displayLCDNumber(0, 4, getMotorEncoder(LFront));
			displayLCDNumber(1, 4, leftControl.err);
		} else if(state == 1) {
			// Display other data:
			displayLCDString(0, 0, "Del:"); // delta
			displayLCDString(1, 0, "Sta:"); // state

			displayLCDNumber(0, 4, lastEncoderDelta);

			if(leftControl.active) {
				displayLCDChar(1, 4, 'L');
			}

			if(rightControl.active) {
				displayLCDChar(1, 5, 'R');
			}

			displayLCDNumber(1, 6, (int)leftControl.output);
			displayLCDChar(1, 9, '/');
			displayLCDNumber(1, 10, (int)rightControl.output);
		} else /* state == 2 */ {
			// Display Right-Side Data:
			displayLCDString(0, 0, "Val:");
			displayLCDString(1, 0, "Err:");

			displayLCDNumber(0, 4, getMotorEncoder(RFront));
			displayLCDNumber(1, 4, rightControl.err);
		}

		if(nLCDButtons == 1) {
			state = 0;
		} else if(nLCDButtons == 2) {
			state = 1;
		} else if(nLCDButtons == 4) {
			state = 2;
		}
		sleep(50);
	}
}

/* Drives a given distance forward or backwards.
 * (Negative values drive the robot backwards.)
 *
 * i.e:
 *  autoDrive(2.0) -> drive 2.0 feet forward
 *  autoDrive(-2.0) -> drive 2.0 feet backward
 *
 * This function is not user-interruptable, but will timeout (if timeout > 0).
 */

void autoDrive(float distance, int timeout) {
	leftControl.gain = leftP;
	rightControl.gain = rightP;

	leftControl.maxOutput = rightControl.maxOutput = maxMotorOut;

	int encoderDelta = -1 * inToEncoderTicks(distance);
	lastEncoderDelta = encoderDelta;

	resetMotorEncoder(LFront);
	resetMotorEncoder(RFront);

	resetTBHData(&leftControl, encoderDelta);
	resetTBHData(&rightControl, encoderDelta);

	bool doTimeout = (timeout > 0);

	int dI = 0;
	
	if(doTimeout)
		clearTimer(T2);

	writeDebugStreamLine("Beginning autoDrive.");

	while(true) {
		bool lCross = leftControl.firstCross;
		bool rCross = rightControl.firstCross;
		tbhControlCycle(&leftControl, getMotorEncoder(LFront));
		tbhControlCycle(&rightControl, getMotorEncoder(RFront));

		/* Test for:
		* More than 1 setpoint crossing.
		* Low output / oscilliation.
		* Close to setpoint.
		*/
		if(!lCross && !rCross &&
			(abs((int)leftControl.output) < 10) && (abs((int)rightControl.output) < 10) &&
			(abs(leftControl.err) < driveErrThreshold) && (abs(rightControl.err) < driveErrThreshold))
		{
			writeDebugStreamLine("autoDrive terminating normally");
			stopMotors();
			leftControl.active = false;
			rightControl.active = false;
			return;
		}

		leftControl.crossed = false;
		rightControl.crossed = false;

		if(doTimeout) {
				if(time1[T2] > timeout) {
					writeDebugStreamLine("autoDrive timed out");
				stopMotors();
				leftControl.active = false;
				rightControl.active = false;
				return;
			}
		}
		
		dI++;
		writeDebugStreamLine("autoDrive, i=%i", dI);

		// dirty hack: I should probably figure out why that's happening, but it's okay for now
		motor[LFront] = motor[LBack] = leftControl.output;
		motor[RFront] = motor[RBack] = rightControl.output;

		sleep(5);
	}
}

/* Note: for a turn to 270 degrees (or any angle above 180)
 * A turn to (angle-360) is better, since it turns a shorter distance (clockwise instead of ccw)
 * Maybe use this library to fix that?: https://github.com/jpearman/RobotCLibs/blob/master/gyroLib/gyroLib2.c
 */

 /* Turn to a given heading as indicated by the gyro.
  * Not user-interruptable, but will timeout if timeout > 0.
  */
void autoTurn(float setpoint, int timeout) {
	turnControl.gain = turnP;
	turnControl.maxOutput = maxMotorOut;

	resetTBHData(&turnControl, setpoint);

	if(timeout > 0)
		clearTimer(T2);

	while(true) {
		bool lastCross = turnControl.firstCross;
		tbhControlCycle(&turnControl, readGyro());

		if(!lastCross && turnControl.crossed && abs((int)turnControl.output) < 10) {
			stopMotors();
			turnControl.active = false;
			return;
		}

		turnControl.crossed = false;

		if((timeout > 0) && (time1[T2] > timeout)) {
			stopMotors();
			turnControl.active = false;
			return;
		}

		motor[LFront] = motor[LBack] = -1*turnControl.output;
		motor[RFront] = motor[RBack] = turnControl.output;

		sleep(2);
	}
}

 /* Turn to a given heading as indicated by the gyro.
  * This will automatically timeout, and can also be interrupted by any input on the controller.
  */

void turnInterruptable(float setpoint) {
	turnControl.gain = turnP;
	turnControl.maxOutput = maxMotorOut;

	resetTBHData(&turnControl, setpoint);

	clearTimer(T2);

	while(true) {
		bool lastCross = turnControl.firstCross;
		tbhControlCycle(&turnControl, readGyro());

		if(!lastCross && turnControl.crossed && abs((int)turnControl.output) < 10) {
			stopMotors();
			turnControl.active = false;
			return;
		}

		if(turnControl.crossed)
			turnControl.crossed = false;

		motor[LFront] = motor[LBack] = -1*turnControl.output;
		motor[RFront] = motor[RBack] = turnControl.output;

		sleep(2);

		if(time1[T2] > interruptableTurnTimeout) {
			stopMotors();
			turnControl.active = false;
			return;
		}

		/* Test for user interrupt: */
		if(
			abs(vexRT[Ch2]) > 5 ||
			abs(vexRT[Ch3]) > 5 ||
			vexRT[Btn5D] ||
			vexRT[Btn5U] ||
			vexRT[Btn7U] ||
			vexRT[Btn7R] ||
			vexRT[Btn7D] ||
			vexRT[Btn7L]
		) {
			stopMotors();
			turnControl.active = false;
			return;
		}
	}
}

void primeShot() {
	motor[rightLowerIntake] = 127;
	motor[rightUpperIntake] = 127;
	motor[leftLowerIntake] = 127;
	motor[leftUpperIntake] = 127;
}

void fireShot() {
	motor[rightLowerIntake] = -127;
	motor[rightUpperIntake] = -127;
	motor[leftLowerIntake] = -127;
	motor[leftUpperIntake] = -127;
}

void holdShot() {
	motor[rightLowerIntake] = 0;
	motor[rightUpperIntake] = 0;
	motor[leftLowerIntake] = 0;
	motor[leftUpperIntake] = 0;
}

void doHang() {
	motor[hangMotor] = 127;
	sleep(500);
	motor[hangMotor] = -127;
	sleep(1000);
	motor[hangMotor] = 0;
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	resetGyro();
	resetEncoders();
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

void autoShoot() {
	primeShot();
	if(limSwitchEnabled) {
		clearTimer(T2);
		while(time1[T2] < 750 && sensorValue[catapultLim] == 0) { sleep(2);}
	} else {
		sleep(750);
	}
	holdShot();
	sleep(50);
	fireShot();
}

bool onRightSide = true;

/* Drive forward and back to unlock the mechanism. */
void doShakeRoutine() {
	motor[LBack] = motor[LFront] = motor[RBack] = motor[RFront] = 127;
	sleep(250);
	motor[LBack] = motor[LFront] = motor[RBack] = motor[RFront] = -127;
	sleep(250);
	motor[LBack] = motor[LFront] = motor[RBack] = motor[RFront] = 0;
}

task autonomous()
{
	writeDebugStreamLine("Beginning auto code.");
	autoMode = true;

	resetGyro();
	resetEncoders();

	datalogClear();
	
	/*
	 Auto test routine:
	 */
	//startTask(autoDriveDebug);
	autoDrive(7.0 * 12.0, -1);

	writeDebugStreamLine("Control fell through.");
	
	while(true) {sleep(5);}

	/* Raise the hang mechanism slightly. */
	/*
	motor[hangMotor] = 16;
	sleep(250);
	motor[hangMotor] = 0;

	turnInterruptable(180);
	autoShoot();
	*/

	/* Move to high hang position from start: */
	/*
	fireShot();
	sleep(250);
	primeShot();
	sleep(750);
	holdShot();
	sleep(100);

	turnInterruptable(-90);
	motor[RBack] = motor[RFront] = motor[LBack] = motor[LFront] = 127;

	if(!onRightSide) {
		sleep(1500);
	} else {
		sleep(250);
	}

	stopMotors();
	turnInterruptable(0);

	fireShot();
	sleep(250);

	motor[RBack] = motor[RFront] = motor[LBack] = motor[LFront] = -32;
	sleep(100);

	stopMotors();
	*/
	/* Do the rest of the high hang stuff. */

	//doHang();
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

/* Manual control parameters: */
bool tankDriveActive = false;
const int deadband = 25;
int manualTurnOut = 32;

int absoluteMaxDrive = 96;

task lowerCatapultAsync() {
	primeShot();
	clearTimer(T2);
	while(time1[T2] < 2000 && sensorValue[catapultLim] == 0) { sleep(2); }
	holdShot();
}

void lowerCatapult() {
	primeShot();
	clearTimer(T2);
	while(time1[T2] < 2000 && sensorValue[catapultLim] == 0) { sleep(2); }
	holdShot();
}

void fireCatapult() {
	fireShot();
	sleep(500);
	holdShot();
}

task usercontrol()
{
	resetGyro();

	//startTask(LCDUpdate);

	while (true)
	{
		/* Fire control: */
		if(!limSwitchEnabled) {
			if(vexRT[Btn6U] && !vexRT[Btn6D]) {
				primeShot();
			} else if(!vexRT[Btn6U] && vexRT[Btn6D]) {
				fireShot();
			} else if(!vexRT[Btn6U] && !vexRT[Btn6D]) {
				holdShot();
			}
		} else {
			if(vexRT[Btn6U] && !vexRT[Btn6D] && sensorValue[catapultLim] == 0) {
				primeShot();
				startTask(lowerCatapultAsync);
			} else if(!vexRT[Btn6U] && vexRT[Btn6D]) {
				fireCatapult();
			} else if(!vexRT[Btn6U] && !vexRT[Btn6D]) {
				holdShot();
			}
		}

		/* Hang control */
		if( vexRT[Btn5U] && !vexRT[Btn5D] ) {
			motor[hangMotor] = 127;
		} else if( vexRT[Btn5D] && !vexRT[Btn5U] ) {
			motor[hangMotor] = -127;
		} else if( !vexRT[Btn5D] && !vexRT[Btn5U] ) {
			motor[hangMotor] = 0;
		}

		/* Movement control: */
		if( vexRT[Btn8D] || vexRT[Btn8U] ) {
			/* Rotation inputs: */
			motor[LBack] = motor[LFront] = (vexRT[Btn8D] ? -1*manualTurnOut : manualTurnOut);
			motor[RBack] = motor[RFront] = (vexRT[Btn8D] ? manualTurnOut : -1*manualTurnOut);
		} else if(
			vexRT[Btn7U] ||
			vexRT[Btn7D] ||
			vexRT[Btn7R] ||
			vexRT[Btn7L]
		) /* If any button in group 7 is pressed... */ {
			/* Absolute rotation buttons: */
			if(vexRT[Btn7U]) {
				turnInterruptable(0);
			} else if(vexRT[Btn7R]) {
				turnInterruptable(-90);
			} else if(vexRT[Btn7D]) {
				turnInterruptable(180);
			} else if(vexRT[Btn7L]) {
				turnInterruptable(90);
			}
		} else {
			if(tankDriveActive) {
				/* Tank Drive inputs: */
				motor[LBack] = motor[LFront]
					= (abs(vexRT[Ch3]) > absoluteMaxDrive) ? (sgn(vexRT[Ch3])*absoluteMaxDrive) : vexRT[Ch3];
				motor[RBack] = motor[RFront]
						= (abs(vexRT[Ch2]) > absoluteMaxDrive) ? (sgn(vexRT[Ch2])*absoluteMaxDrive) : vexRT[Ch2];
			} else {
				short yAxis = (abs(vexRT[Ch2]) < deadband) ? 0 : -vexRT[Ch2];
				short zAxis = (abs(vexRT[Ch1]) < deadband) ? 0 : -vexRT[Ch1];

				short right = yAxis - zAxis;
				short left = yAxis + zAxis;

				right = (abs(right) > absoluteMaxDrive) ? (sgn(right)*absoluteMaxDrive) : right;
				left = (abs(left) > absoluteMaxDrive) ? (sgn(left)*absoluteMaxDrive) : left;

				motor[RFront] = motor[RBack] = right;
				motor[LFront] = motor[LBack] = left;
			}
		}

		sleep(1);
	}
}