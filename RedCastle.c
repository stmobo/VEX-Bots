#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Motor,  port1,           RBack,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           RFront,        tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port9,           LFront,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          LBack,         tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
  // .....................................................................................
  // Insert user code here.
  // .....................................................................................

	AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

bool controlActive = false; /* Will be set to true if the control loop is active. */
bool turning = false;				/* Will be set to true if controlActive && (robot is executing a turn) */

bool startDrive = false;		/* Set to true to request control loop activation. */
bool startTurn = false;			/* Set to true to request a turn. */

bool controlComplete = false;	/* Will be set to true when the Control Loop has relinquished control of the robot. */

float turnSetpoint = 0;	/* in degrees */
int driveSetpoint = 0; 	/* in encoder ticks */

/* Internal variables! */
int driveStartpoint = 0;
float turnStartpoint = 0;

/* Loop parameters */
float driveP = 1.0;
float turnP = 1.0;
int maxMotorOut = 63;

float turnErrThreshold = 1.0;
int driveErrThreshold = 5;

int readDriveEncoder() {
	return -1; // TODO: Replace with actual encoder reading code
}

/* Gyro positive = clockwise, gyro negative = ccw */
float readGyro() {
	float v = (float)SensorValue[gyro];
	v /= 10;
	return v;
}

void resetCL() {
	controlActive = false;
	turning = false;
	
	controlDone = true;

	turnSetpoint = 0;
	driveSetpoint = 0;
	
	turnStartpoint = 0;
	driveStartpoint = 0;
}

task robotControlLoop() {
	while(true) {
		if(controlActive) {
			if(turning) {
				float curGyro = readGyro();
				float err = (turnSetpoint - curGyro);
				
				if(err < turnErrThreshold) {
					resetCL();
					goto controlLoopDone;
				}	
				
				int out = (err * turnP);
				
				if(out > maxMotorOut) out = maxMotorOut;
								
				motor[LFront] = out;
				motor[LBack] = out;
				
				motor[RFront] = out * -1;
				motor[RBack] = out * -1;
			} else {
				int curEnc = readDriveEncoder();
				int err = (driveSetpoint - curEnc);
				
				if(err < driveErrThreshold) {
					resetCL();
					goto controlLoopDone;
				}
				
				int out = (err * driveP);
				if(out > maxMotorOut) out = maxMotorOut;
				
				motor[LFront] = out;
				motor[RFront] = out;
				motor[RBack] = out;
				motor[LBack] = out;
			}
		} else if(startDrive) {
			controlActive = true;
			
			if(startTurn) {
				/* Init turn: */
				turnStartpoint = readGyro();
				turning = true;
			} else {
				driveStartpoint = readDriveEncoder();			
			}	/* startTurn */
			
			startDrive = false;
			startTurn = false;		
		} /* controlActive / startDrive */
		
		controlLoopDone:
		sleep(2);
	}
}

task usercontrol()
{
	// User control code here, inside the loop

	while (true)
	{
	}
}