#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Motor,  port1,           RBack,         tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           RFront,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           LFront,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          LBack,         tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

void resetGyro() {
	sensorValue[gyro] = 0;
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	resetGyro();
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
  // .....................................................................................
  // Insert user code here.
  // .....................................................................................

	AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

bool controlActive = false; /* Will be set to true if the control loop is active. */
bool turning = false;				/* Will be set to true if controlActive && (robot is executing a turn) */

bool startDrive = false;		/* Set to true to request control loop activation. */
bool startTurn = false;			/* Set to true to request a turn. */

bool controlComplete = false;	/* Will be set to true when the Control Loop has relinquished control of the robot. */

float turnSetpoint = 0;	/* in degrees */
int driveSetpoint = 0; 	/* in encoder ticks */

/* Internal variables! */
int driveStartpoint = 0;
float turnStartpoint = 0;

/* Loop parameters */
float driveP = 1.0;
float turnP = 1.0;
int maxMotorOut = 63;

float turnErrThreshold = 1.0;
int driveErrThreshold = 5;

int readDriveEncoder() {
	return -1; // TODO: Replace with actual encoder reading code
}

/* Gyro positive = clockwise, gyro negative = ccw */
float readGyro() {
	float v = (float)SensorValue[gyro];
	v /= 10;
	return v;
}

void resetCL() {
	controlActive = false;
	turning = false;

	//controlDone = true;

	turnSetpoint = 0;
	driveSetpoint = 0;

	turnStartpoint = 0;
	driveStartpoint = 0;
}

task LCDUpdate() {
	while(true) {
		float curAngle = readGyro();

		clearLCDLine(0);
		clearLCDLine(1);

		displayLCDString(0, 0, "Deg ");
		displayLCDNumber(0, 4, (int)curAngle);

		sleep(5);
	}
}

void stopMotors() {
	motor[LBack] = motor[LFront] = motor[RBack] = motor[RFront] = 0;
}

void turnInterruptable(float setpoint) {
	while(true) {
		float curAngle = readGyro();
		float err = (setpoint - curAngle);

		if(abs(err) < turnErrThreshold) {
			stopMotors();
			return;
		}

		int out = (err * turnP);
		out = (out>maxMotorOut?maxMotorOut:out);

		motor[LFront] = motor[LBack] = -1*out;
		motor[RFront] = motor[RBack] = out;

		sleep(2);

		if(
			abs(vexRT[Ch2]) > 5 ||
			abs(vexRT[Ch3]) > 5 ||
			vexRT[Btn5D] ||
			vexRT[Btn5U] ||
			vexRT[Btn7U] ||
			vexRT[Btn7R] ||
			vexRT[Btn7D] ||
			vexRT[Btn7L]
		) {
			stopMotors();
			return;
		}
	}
}

void primeShot() {
		// TODO: Fill this in later
}

void fireShot() {
		// TODO: Fill this in later
}

int turnOut = 63; // absolute value

task usercontrol()
{
	resetGyro();

	startTask(LCDUpdate);

	while (true)
	{
		if( vexRT[Btn5D] || vexRT[Btn5U] ) {
			/* Rotation inputs: */
			motor[LBack] = motor[LFront] = (vexRT[Btn5D] ? -1*turnOut : turnOut);
			motor[RBack] = motor[RFront] = (vexRT[Btn5D] ? turnOut : -1*turnOut);
		} else if(
			vexRT[Btn7U] ||
			vexRT[Btn7D] ||
			vexRT[Btn7R] ||
			vexRT[Btn7L]
		) /* If any button in group 7 is pressed... */ {
			/* Absolute rotation buttons: */
			if(vexRT[Btn7U]) {
				turnInterruptable(0);
			} else if(vexRT[Btn7R]) {
				turnInterruptable(270);
			} else if(vexRT[Btn7D]) {
				turnInterruptable(180);
			} else if(vexRT[Btn7L]) {
				turnInterruptable(90);
			}
		} else {
			/* Tank Drive inputs: */
			motor[LBack] = motor[LFront] = vexRT[Ch3];
			motor[RBack] = motor[RFront] = vexRT[Ch2];
		}
	}
}
