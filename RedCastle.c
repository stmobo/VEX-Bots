#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Motor,  port1,           RBack,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           RFront,        tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port9,           LFront,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          LBack,         tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
  // .....................................................................................
  // Insert user code here.
  // .....................................................................................

	AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

bool controlActive = false; /* Will be set to true if the control loop is active. */
bool turning = false;				/* Will be set to true if controlActive && (robot is executing a turn) */

bool startDrive = false;		/* Set to true to request control loop activation. */
bool startTurn = false;			/* Set to true to request a turn. */

bool controlComplete = false;	/* Will be set to true when the Control Loop has relinquished control of the robot. */

float turnSetpoint = 0;	/* in degrees */
int driveSetpoint = 0; 	/* in encoder ticks */

/* Internal variables! */
int driveStartpoint = 0;
float turnStartpoint = 0;

/* Loop parameters */
float driveP = 1.0;
float turnP = 1.0;
int maxMotorOut = 63;

float turnErrThreshold = 1.0;
int driveErrThreshold = 5;

int readDriveEncoder() {
	return -1; // TODO: Replace with actual encoder reading code
}

/* Gyro positive = clockwise, gyro negative = ccw */
float readGyro() {
	float v = (float)SensorValue[gyro];
	v /= 10;
	return v;
}

void resetCL() {
	controlActive = false;
	turning = false;
	
	//controlDone = true;

	turnSetpoint = 0;
	driveSetpoint = 0;
	
	turnStartpoint = 0;
	driveStartpoint = 0;
}

task LCDUpdate() {
	while(true) {
		float y = ((float)vexRT[Ch2] / 127.0);
		float x = ((float)vexRT[Ch1] / 127.0);
		
		float angle = (atan2(y, x) * (180.0 / PI));
		
		if(vexRT[Ch2] < 0) {
			angle = (angle) + 180;		
		} if((vexRT[Ch1] < 0) && (vexRT[Ch2] > 0)) {
			angle = (angle + 90);
		} else {
			angle = 90 - angle;
		}
		
		
		float mag = sqrt(y*y + x*x);
		
		float curAngle = readGyro();
		
		clearLCDLine(0);
		clearLCDLine(1);
		
		displayLCDString(0, 0, "Y ### X ###");
		displayLCDString(1, 0, "Ang ");
		
		displayLCDNumber(0, 2, (int)(y*100));
		displayLCDNumber(0, 7, (int)(x*100));
		displayLCDNumber(1, 5, (int)angle);
	}
}

task usercontrol()
{
	// User control code here, inside the loop

	startTask(LCDUpdate);

	while (true)
	{
		float y = ((float)vexRT[Ch2] / 127.0);
		float x = ((float)vexRT[Ch1] / 127.0);
		
		float angle = (atan2(y, x) * (180 / PI));
		
		
		if(y < 0) {
			angle = fabs(angle) + 90;		
		} if(x < 0 && y > 0) {
			angle = (angle + 90);
		} else {
			angle = 90 - angle;
		}

		
		float mag = sqrt(y*y + x*x);
		
		float curAngle = readGyro();
		float err = angle - curAngle;
		
		if((abs(err) < turnErrThreshold)
			|| ((vexRT[Ch1] < driveErrThreshold) && (vexRT[Ch2] < driveErrThreshold))) {
			motor[LFront] = 0;
			motor[LBack] = 0;
			motor[RFront] = 0;
			motor[RBack] = 0;
		} else {
			int out = (int)((float)err * (float)turnP);
			
			if(abs(out) > maxMotorOut) out = maxMotorOut;
							
			motor[LFront] = out;
			motor[LBack] = out;
			
			motor[RFront] = out * -1;
			motor[RBack] = out * -1;
		}
	}
}