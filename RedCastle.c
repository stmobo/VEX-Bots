#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Motor,  port1,           RBack,         tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           RFront,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           LFront,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          LBack,         tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

void resetGyro() {
	sensorValue[gyro] = 0;
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	resetGyro();
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
  // .....................................................................................
  // Insert user code here.
  // .....................................................................................

	AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

bool controlActive = false; /* Will be set to true if the control loop is active. */
bool turning = false;				/* Will be set to true if controlActive && (robot is executing a turn) */

bool startDrive = false;		/* Set to true to request control loop activation. */
bool startTurn = false;			/* Set to true to request a turn. */

bool controlComplete = false;	/* Will be set to true when the Control Loop has relinquished control of the robot. */

float turnSetpoint = 0;	/* in degrees */
int driveSetpoint = 0; 	/* in encoder ticks */

/* Internal variables! */
int driveStartpoint = 0;
float turnStartpoint = 0;

/* Loop parameters */
float driveP = 1.0;
float turnP = 0.7;
int maxMotorOut = 63;

float turnErrThreshold = 1.0;
int driveErrThreshold = 5;

int readDriveEncoder() {
	return -1; // TODO: Replace with actual encoder reading code
}

/* Gyro positive = clockwise, gyro negative = ccw */
float readGyro() {
	float v = (float)SensorValue[gyro];
	v /= 10;
	return v;
}

void resetCL() {
	controlActive = false;
	turning = false;

	//controlDone = true;

	turnSetpoint = 0;
	driveSetpoint = 0;

	turnStartpoint = 0;
	driveStartpoint = 0;
}

task LCDUpdate() {
	while(true) {
		float curAngle = readGyro();

		clearLCDLine(0);
		clearLCDLine(1);

		displayLCDString(0, 0, "Deg ");
		displayLCDNumber(0, 4, (int)curAngle);

		sleep(5);
	}
}

void stopMotors() {
	motor[LBack] = motor[LFront] = motor[RBack] = motor[RFront] = 0;
}

struct tbhData {
	float setpoint;
	float err;
	int lastSign;
	
	float output;
	float lOutput;
	float maxOutput;
	float gain;
	
	bool firstCross;
};

tbhData turnControl;

void resetTBHData(tbhData* st, float setpoint) {
	st->setpoint = setpoint;
	st->err = 0;
	st->output = 0;
	st->lOutput = 0;
	st->lastSign = 0;
	st->firstCross = true;
}


/*
 * TBH Control Loop: (for S = setpoint)
 *  o V <- sensor
 *  o E <- (S - V)
 *  If V has crossed S: Out <- ((E*gain) + (lastOut)) / 2
 *  Else: o Out <- E * gain 
 */

void tbhControlCycle(tbhData *st, float sensorIn) {
	float err = (st->setpoint - sensorIn);
	
	st->err = err;
	
	float curOut = (err * st->gain);
	if(sgn((int)err) != 0 && sgn((int)err) != st->lastSign) {
		/* Sign change */
		st->lastSign = sgn((int)err);
		st->lOutput = st->output = (st->firstCross ? curOut : ((curOut+st->lOutput) / 2) );
	} else {
		st->output = curOut;
	}
	
	if(abs(st->output) > st->maxOutput) {
		st->output = sgn((int)st->output)*st->maxOutput;
	}
}


void turnInterruptable(float setpoint) {
	turnControl.gain = turnP;
	turnControl.maxOutput = maxMotorOut;
	
	resetTBHData(&turnControl, setpoint);
	
	while(true) {
		tbhControlCycle(&turnControl, readGyro());
		
		if(abs(turnControl.err) < turnErrThreshold) {
			stopMotors();
			return;
		}

		motor[LFront] = motor[LBack] = -1*turnControl.output;
		motor[RFront] = motor[RBack] = turnControl.output;

		sleep(2);

		if(
			abs(vexRT[Ch2]) > 5 ||
			abs(vexRT[Ch3]) > 5 ||
			vexRT[Btn5D] ||
			vexRT[Btn5U] ||
			vexRT[Btn7U] ||
			vexRT[Btn7R] ||
			vexRT[Btn7D] ||
			vexRT[Btn7L]
		) {
			stopMotors();
			return;
		}
	}
}

void primeShot() {
		// TODO: Fill this in later
}

void fireShot() {
		// TODO: Fill this in later
}

int turnOut = 63; // absolute value

task usercontrol()
{
	resetGyro();

	startTask(LCDUpdate);

	while (true)
	{
		if( vexRT[Btn5D] || vexRT[Btn5U] ) {
			/* Rotation inputs: */
			motor[LBack] = motor[LFront] = (vexRT[Btn5D] ? -1*turnOut : turnOut);
			motor[RBack] = motor[RFront] = (vexRT[Btn5D] ? turnOut : -1*turnOut);
		} else if(
			vexRT[Btn7U] ||
			vexRT[Btn7D] ||
			vexRT[Btn7R] ||
			vexRT[Btn7L]
		) /* If any button in group 7 is pressed... */ {
			/* Absolute rotation buttons: */
			if(vexRT[Btn7U]) {
				turnInterruptable(0);
			} else if(vexRT[Btn7R]) {
				turnInterruptable(270);
			} else if(vexRT[Btn7D]) {
				turnInterruptable(180);
			} else if(vexRT[Btn7L]) {
				turnInterruptable(90);
			}
		} else {
			/* Tank Drive inputs: */
			motor[LBack] = motor[LFront] = vexRT[Ch3];
			motor[RBack] = motor[RFront] = vexRT[Ch2];
		}
	}
}