#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  catapultLim,    sensorTouch)
#pragma config(Motor,  port1,           RBack,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           RFront,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           rightLowerIntake, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rightUpperIntake, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           hangMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           leftUpperIntake, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           leftLowerIntake, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           LFront,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          LBack,         tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/* Internal variables! */
int driveStartpoint = 0;
float turnStartpoint = 0;

/* Loop parameters */
float driveP = 3.0;
float turnP = 2;
int maxMotorOut = 63;

float turnErrThreshold = 1.0;
int driveErrThreshold = 5;

int autoTurnTimeout = 2000;

bool limSwitchEnabled = false;

struct tbhData {
	/* Internal variables: */
	float err;		/* Control loop error. */
	int lastSign;		/* Sign of err on last cycle. */
	float lOutput;		/* Output value from last setpoint crossing. */
	bool firstCross;	/* Will be set to FALSE after the first setpoint crossing. */

	/* Input parameters: */
	float setpoint;
	float gain;
	float maxOutput;	/* this->output will be capped to +/-(this->maxOutput). */

	float output;		/* Control output. (e.g. motor power) */

	/* Output event flags. Clear these after handling their event. */
	bool crossed;		/* Will be set to TRUE on a setpoint crossing. */
	bool active;		/* Will be set to TRUE on every tbhControlCycle(). */
};

tbhData turnControl;
tbhData driveControl;

bool autoMode = false;

int readDriveEncoder() {
	return -1; // TODO: Replace with actual encoder reading code
}

void resetGyro() {
	sensorValue[gyro] = 0;
}

/* Gyro positive = ccw, gyro negative = cw */
float readGyro() {
	float v = (float)SensorValue[gyro];
	v /= 10;
	return v;
}

task LCDUpdate() {
	while(true) {
		float curAngle = readGyro();

		clearLCDLine(0);
		clearLCDLine(1);

		if(turnControl.active) {
			displayLCDString(0, 0, "Turn Active: ");
			displayLCDNumber(0, 13, (int)turnControl.setpoint);


			displayLCDString(1, 0, "Err: ");
			displayLCDNumber(1, 5, (int)turnControl.err);


			displayLCDString(1, 10, "Out: ");
			displayLCDNumber(1, 15, (int)turnControl.output);
		} else if(driveControl.active) {
			displayLCDString(0, 0, "Drive Active: ");
			displayLCDNumber(0, 14, (int)driveControl.setpoint);


			displayLCDString(1, 0, "Err: ");
			displayLCDNumber(1, 5, (int)driveControl.err);


			displayLCDString(1, 10, "Out: ");
			displayLCDNumber(1, 15, (int)driveControl.output);
		} else if(autoMode) {
			displayLCDString(0, 0, "Autonomous Active");
		} else {
			displayLCDString(0, 0, "Driver Controlled");
		}

		sleep(5);
	}
}

void stopMotors() {
	motor[LBack] = motor[LFront] = motor[RBack] = motor[RFront] = 0;
}


void resetTBHData(tbhData* st, float setpoint) {
	st->setpoint = setpoint;
	st->err = 0;
	st->output = 0;
	st->lOutput = 0;
	st->lastSign = 0;
	st->firstCross = true;
	st->crossed = false;
	st->active = false;
}

/*
 * TBH Control Loop: (for S = setpoint)
 *  o V <- sensor
 *  o E <- (S - V)
 *  If V has crossed S: Out <- ((E*gain) + (lastOut)) / 2
 *  Else: o Out <- E * gain
 */

void tbhControlCycle(tbhData *st, float sensorIn) {
	float err = (st->setpoint - sensorIn);

	st->err = err;
	st->active = true;

	float curOut = (err * st->gain);
	if(sgn((int)err) != 0 && sgn((int)err) != st->lastSign) {
		/* Sign change */
		st->lastSign = sgn((int)err);
		st->lOutput = st->output = (st->firstCross ? curOut : ((curOut+st->lOutput) / 2) );
		st->firstCross = false;
		st->crossed = true;
	} else {
		st->output = curOut;
	}

	if(abs(st->output) > st->maxOutput) {
		st->output = sgn((int)st->output)*st->maxOutput;
	}
}

/*
 * How to use TBHData:
 *  - Call resetTBHData(&your_tbh_struct, setpoint);
 *  - Ensure your gain and maxOutput variables are set (set all input parameters)
 *  - In a loop:
 *   o Call tbhControlCycle(&your_tbh_struct, sensor_input). This does the important control loop calculations, etc.
 *   o Handle raised events as necessary.
 *   o Do everything else. For example, actually using the output value(!) or checking exit conditions(!).
 *  - When done, make sure to set your_tbh_struct.active to FALSE for the benefit of any listeners.
 *
 * For a good example, see turnInterruptable() below.
 */

/* Note: for a turn to 270 degrees (or any angle above 180)
 * A turn to (angle-360) is better, since it turns a shorter distance (clockwise instead of ccw)*/
void turnInterruptable(float setpoint) {
	turnControl.gain = turnP;
	turnControl.maxOutput = maxMotorOut;

	resetTBHData(&turnControl, setpoint);

	clearTimer(T2);

	while(true) {
		bool lastCross = turnControl.firstCross;
		tbhControlCycle(&turnControl, readGyro());

		if(!lastCross && turnControl.crossed && abs((int)turnControl.output) < 10) {
			stopMotors();
			turnControl.active = false;
			return;
		}

		if(turnControl.crossed)
			turnControl.crossed = false;

		motor[LFront] = motor[LBack] = -1*turnControl.output;
		motor[RFront] = motor[RBack] = turnControl.output;

		sleep(2);

		if(time1[T2] > autoTurnTimeout) {
			stopMotors();
			turnControl.active = false;
			return;
		}

		if(
			abs(vexRT[Ch2]) > 5 ||
			abs(vexRT[Ch3]) > 5 ||
			vexRT[Btn5D] ||
			vexRT[Btn5U] ||
			vexRT[Btn7U] ||
			vexRT[Btn7R] ||
			vexRT[Btn7D] ||
			vexRT[Btn7L]
		) {
			stopMotors();
			turnControl.active = false;
			return;
		}
	}
}

void primeShot() {
	motor[rightLowerIntake] = 127;
	motor[rightUpperIntake] = 127;
	motor[leftLowerIntake] = 127;
	motor[leftUpperIntake] = 127;
}

void fireShot() {
	motor[rightLowerIntake] = -127;
	motor[rightUpperIntake] = -127;
	motor[leftLowerIntake] = -127;
	motor[leftUpperIntake] = -127;
}

void holdShot() {
	motor[rightLowerIntake] = 0;
	motor[rightUpperIntake] = 0;
	motor[leftLowerIntake] = 0;
	motor[leftUpperIntake] = 0;
}

void doHang() {
	motor[hangMotor] = 127;
	sleep(500);
	motor[hangMotor] = -127;
	sleep(1000);
	motor[hangMotor] = 0;
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	resetGyro();
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

void autoShoot() {
	primeShot();
	if(limSwitchEnabled) {
		clearTimer(T2);
		while(time1[T2] < 750 && sensorValue[catapultLim] == 0) { sleep(2);}
	} else {
		sleep(750);
	}
	holdShot();
	sleep(50);
	fireShot();
}

bool onRightSide = true;

task autonomous()
{
	autoMode = true;

	/* Raise the hang mechanism slightly. */
	/*
	motor[hangMotor] = 16;
	sleep(250);
	motor[hangMotor] = 0;

	turnInterruptable(180);
	autoShoot();
	*/

	/* Move to high hang position from start: */
	/*
	fireShot();
	sleep(250);
	primeShot();
	sleep(750);
	holdShot();
	sleep(100);

	turnInterruptable(-90);
	motor[RBack] = motor[RFront] = motor[LBack] = motor[LFront] = 127;

	if(!onRightSide) {
		sleep(1500);
	} else {
		sleep(250);
	}

	stopMotors();
	turnInterruptable(0);

	fireShot();
	sleep(250);

	motor[RBack] = motor[RFront] = motor[LBack] = motor[LFront] = -32;
	sleep(100);

	stopMotors();
	*/
	/* Do the rest of the high hang stuff. */

	//doHang();
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

/* Manual control parameters: */
bool tankDriveActive = false;
const int deadband = 25;
int manualTurnOut = 32;

int absoluteMaxDrive = 96;

task lowerCatapultAsync() {
	primeShot();
	clearTimer(T2);
	while(time1[T2] < 2000 && sensorValue[catapultLim] == 0) { sleep(2); }
	holdShot();
}

void lowerCatapult() {
	primeShot();
	clearTimer(T2);
	while(time1[T2] < 2000 && sensorValue[catapultLim] == 0) { sleep(2); }
	holdShot();
}

void fireCatapult() {
	fireShot();
	sleep(500);
	holdShot();
}

task usercontrol()
{
	resetGyro();

	startTask(LCDUpdate);

	while (true)
	{
		/* Fire control: */
		if(!limSwitchEnabled) {
			if(vexRT[Btn6U] && !vexRT[Btn6D]) {
				primeShot();
			} else if(!vexRT[Btn6U] && vexRT[Btn6D]) {
				fireShot();
			} else if(!vexRT[Btn6U] && !vexRT[Btn6D]) {
				holdShot();
			}
		} else {
			if(vexRT[Btn6U] && !vexRT[Btn6D] && sensorValue[catapultLim] == 0) {
				primeShot();
				startTask(lowerCatapultAsync);
			} else if(!vexRT[Btn6U] && vexRT[Btn6D]) {
				fireCatapult();
			} else if(!vexRT[Btn6U] && !vexRT[Btn6D]) {
				holdShot();
			}
		}

		/* Hang control */
		if( vexRT[Btn5U] && !vexRT[Btn5D] ) {
			motor[hangMotor] = 127;
		} else if( vexRT[Btn5D] && !vexRT[Btn5U] ) {
			motor[hangMotor] = -127;
		} else if( !vexRT[Btn5D] && !vexRT[Btn5U] ) {
			motor[hangMotor] = 0;
		}

		/* Movement control: */
		if( vexRT[Btn8D] || vexRT[Btn8U] ) {
			/* Rotation inputs: */
			motor[LBack] = motor[LFront] = (vexRT[Btn8D] ? -1*manualTurnOut : manualTurnOut);
			motor[RBack] = motor[RFront] = (vexRT[Btn8D] ? manualTurnOut : -1*manualTurnOut);
		} else if(
			vexRT[Btn7U] ||
			vexRT[Btn7D] ||
			vexRT[Btn7R] ||
			vexRT[Btn7L]
		) /* If any button in group 7 is pressed... */ {
			/* Absolute rotation buttons: */
			if(vexRT[Btn7U]) {
				turnInterruptable(0);
			} else if(vexRT[Btn7R]) {
				turnInterruptable(-90);
			} else if(vexRT[Btn7D]) {
				turnInterruptable(180);
			} else if(vexRT[Btn7L]) {
				turnInterruptable(90);
			}
		} else {
			if(tankDriveActive) {
				/* Tank Drive inputs: */
				motor[LBack] = motor[LFront]
					= (abs(vexRT[Ch3]) > absoluteMaxDrive) ? (sgn(vexRT[Ch3])*absoluteMaxDrive) : vexRT[Ch3];
				motor[RBack] = motor[RFront]
						= (abs(vexRT[Ch2]) > absoluteMaxDrive) ? (sgn(vexRT[Ch2])*absoluteMaxDrive) : vexRT[Ch2];
			} else {
				short yAxis = (abs(vexRT[Ch2]) < deadband) ? 0 : -vexRT[Ch2];
				short zAxis = (abs(vexRT[Ch1]) < deadband) ? 0 : -vexRT[Ch1];

				short right = yAxis - zAxis;
				short left = yAxis + zAxis;
				
				right = (abs(right) > absoluteMaxDrive) ? (sgn(right)*absoluteMaxDrive) : right;
				left = (abs(left) > absoluteMaxDrive) ? (sgn(left)*absoluteMaxDrive) : left;
				
				motor[RFront] = motor[RBack] = right;
				motor[LFront] = motor[LBack] = left;
			}
		}

		sleep(1);
	}
}